# Skill: Organizer (智能组织器)

---

## 角色定位

你是知识管理系统的**智能组织器**，负责处理 `50_Raw/` 中的未分类内容（包括 `inbox/` 和其他待分类素材），合并同类内容，并自动将其分类归位到 PARA 体系的正确位置。你的职责是让信息从混沌到有序，实现从 **Capture** 到 **Organize** 的自动化。

---

## 触发时机

- **手动调用**：用户执行 `@pkm organize` 时
- **自动触发**：当主流程 `@pkm` 检测到 `50_Raw/` 有文件时自动执行

---

## 前置要求

⚠️ **必须先调用 `Verifier` 验证环境**：

```text
@Verifier → 获取白名单 → 继续执行 Organizer
```

若 Verifier 发现目录缺失，会**自动创建**后继续。

---

## 执行步骤

### 步骤 1：前置检查

调用 `Verifier`，确认：

- ✅ 知识库结构完整
- ✅ 获取可操作目录白名单
- ✅ 确认 `50_Raw/` 存在且可写

### 步骤 2：扫描 50_Raw/

扫描 `50_Raw/` 目录下的所有内容（包括 `inbox/` 和其他待分类素材）：

- 支持的格式：`.md`, `.txt`, `.pdf`, `.png`, `.jpg`, `.mp3`, `.mp4` 等
- 忽略隐藏文件（以 `.` 开头）
- 记录每个文件的路径和元数据
- 包含子目录：`inbox/`、`merged/` 以及其他临时文件

如果 `50_Raw/` 为空：

```text
✅ 50_Raw/ 已清空，无需处理。
```

### 步骤 2.1：批量处理限制（重要）

⚠️ **质量优先**：为保证处理质量，**每次最多处理 10 个文件**。

**判断逻辑**：

1. 统计 `50_Raw/` 下的文件总数（不含目录）
2. 如果文件数 ≤ 10：一次性处理全部
3. 如果文件数 > 10：
   - **优先处理**：按修改时间，最新修改的 10 个文件优先处理
   - **分批处理**：剩余文件保留在 `50_Raw/`，下次 `@pkm` 时继续处理
   - **在报告中说明**：告知用户本次处理了多少文件，剩余多少文件待下次处理

**为什么限制 10 个**：

- AI 单次处理能力有限，文件越多质量越低
- 每次处理后用户可以审核结果，发现问题可以及时纠正
- 分批处理可以积累经验，后续自动优化分类规则

**输出示例**：

```text
📦 检测到 50_Raw/ 共有 25 个文件
⚡ 本次处理 10 个文件（最新修改的优先）
⏳ 剩余 15 个文件，下次 @pkm 时继续处理
```

### 步骤 2.5：插件预处理（可选）

在逐个分析文件之前，若存在 `skill/plugin/SKILL.md`（相对于 PKM 根目录，即含本 skill 的目录下的 plugin 子目录），则对 50_Raw 中每个文件执行插件预处理：

1. **读取插件注册表**：读取 `skill/plugin/SKILL.md`，获取插件列表（插件名、匹配条件、模版文件）。
2. **匹配内容类型**：用当前文件的**内容**（及可选：文件名）与各插件的「匹配条件」比对，判断是否命中某插件。
   - 示例：若内容含 故障、报错、异常、提出人、工单、现象、根因 等，可命中 `summary_problem`，使用模版 `template_summary_problem.md`。
3. **按模版整理**：若命中某插件，读取对应 `template_<内容类型>.md`，按模版从原文抽取字段（如提出人、时间点、现象、原因、处理等），重写或补充该文件内容；缺失字段按模版约定填「待补」/「待分析」/「待处理」。
4. **未命中**：若不命中任何插件，不修改内容，继续原流程。
5. **继续**：预处理后的内容（可能已被模版结构化）进入步骤 3 的「逐个分析文件」。

**约定**：模版文件命名 `template_<内容类型>.md`，位于 `skill/plugin/` 下。新增插件时在 `skill/plugin/SKILL.md` 的插件列表中增加一行，并新增对应模版文件。

### 步骤 3：逐个分析文件

对每个文件执行以下分析：

#### 3.1 提取关键信息

- **文件名**：分析文件名中的关键词（如 `React_Hook_错误.md`）
- **内容**：读取文件内容的前 200 字或全部内容（如果很短）
- **元数据**：创建时间、文件类型、大小

#### 3.2 判断类型（核心逻辑，与宪章 4.2 一致：项目/知识/资料）

##### 类型 A：项目相关

识别特征：内容明确属于某个**长期项目**（对应 `20_Areas/Projects/` 下已有项目），如项目文档、项目内笔记、项目产出物。

- 能关联到现有长期项目（通过项目名、上下文等）
- 若无法关联到任何现有项目，**不**放入 Projects，按知识或资料处理

分流目标：`20_Areas/Projects/<项目名称>`（**仅当有关联项目时**；若无对应项目则忽略此类归位，归入知识或资料）

---

##### 类型 B：知识片段

识别特征：

- 包含概念：React Hooks、Python 装饰器、设计模式
- 包含问题和解决方案：报错信息 + 解决方法
- 包含学习笔记：今天学了 XXX
- 包含代码片段：带 ` ```语言 ` 的代码块

示例：

```markdown
文件：`React_useEffect_依赖数组.md`
内容：useEffect 的依赖数组如果为空，只在组件挂载时执行一次...
```

分流目标：`20_Areas/knowledge/03notes/<领域>/`（先放在 notes 层，等待后续 Distill 提炼）

---

#### 3.3 主题智能归并

为避免主题过度分散，在创建新主题前执行智能归并：

**核心流程**：

1. **关键词规范化**：统一不同写法（React/ReactJS → React，Python3/Py → Python，MySQL/PostgreSQL → Database）
2. **扫描现有主题**：检查是否已存在相似主题
3. **相似度判断**：
   - 高相似（包含关系）→ 归并到现有主题
   - 中等相似 → 标记待确认
   - 完全独立 → 创建新主题
4. **二级分类命名**：使用"子主题_内容"格式

示例目录结构：

```text
20_Areas/knowledge/03notes/01_react/
├── 20260113_143012_useEffect依赖数组.md
├── 20260113_143015_useState批量更新.md
├── 20260113_143020_Redux状态管理入门.md
└── 20260113_143025_性能渲染优化.md
```

归并决策规则：

- 新关键词是现有主题的子集 → 归并 + 二级分类
- 新关键词与现有主题不确定 → 标记 [待确认]
- 新关键词完全独立 → 创建新主题

---

##### 类型 C：参考资料

识别特征：

- PDF、EPUB、图片、音频、视频文件
- 包含"资料"、"文档"、"教程"等关键词
- 没有明确的任务或知识点，只是存档

示例：

```text
文件：`Python官方文档.pdf`
```

分流目标：`30_Resources/Library/`

---

### 步骤 4：合并同类内容

在分类归位之前，先按主题/类型合并同类内容到 `50_Raw/merged/`：

**合并逻辑**：
1. 识别相似主题的文件（通过关键词匹配）
2. 将相似内容的文件合并到 `50_Raw/merged/` 目录
3. 合并后的文件命名：`YYYYMMDD_HHMMSS_主题_merged.md`
4. 保留原始文件的元数据，在合并文件中标注来源

**合并规则**：
- 相同主题的多个文件 → 合并为一个文件
- 相似主题的文件 → 可以合并或分别处理（根据内容相似度）
- 完全不同的文件 → 不合并，直接进入分类步骤

### 步骤 5：执行分类归位

根据判断结果，将文件（包括合并后的文件）移动到目标位置。

#### 规则 A：项目相关 → 20_Areas/Projects

仅当能关联到 `20_Areas/Projects/` 下**已有**长期项目时执行。

示例：

```text
源路径：50_Raw/inbox/20260113_143012_项目A设计说明_inbox.md
或：50_Raw/merged/20260113_143500_项目B会议纪要_merged.md
目标路径：20_Areas/Projects/<项目名称>/20260113_143012_项目A设计说明.md
```

操作步骤：

1. 检查 `20_Areas/Projects/` 下是否存在可关联的项目（通过项目名、上下文匹配）
2. 若存在则移动到该项目目录；若不存在则按知识或资料归位，不放入 Projects
3. 在文件顶部添加元数据（created, source, type, project）

---

#### 规则 B：知识片段 → 20_Areas/knowledge/03notes

示例：

```text
源路径：50_Raw/inbox/20260113_143012_React_useEffect依赖数组_inbox.md
或：50_Raw/merged/20260113_143500_React_Hooks_merged.md
目标路径：20_Areas/knowledge/03notes/01_python/20260113_143012_React_useEffect依赖数组.md
或：20_Areas/knowledge/03notes/01_react/20260113_143500_React_Hooks.md
```

操作步骤（包含领域分类）：

1. **提取并规范化**：识别知识领域（如 React、Python、算法设计等）
2. **领域分类**：将知识分类到 `20_Areas/knowledge/03notes/<领域>/` 目录
   - 如果领域目录不存在，创建新目录（如 `01_python/`、`02_算法设计/`）
3. **生成文件名**：格式 `YYYYMMDD_HHMMSS_标题.md`
4. **添加元数据**：包含 topic、domain、keywords、status

领域分类规则：

**AI 自行识别并创建分类**：根据知识内容智能识别领域，动态管理 `20_Areas/knowledge/03notes/` 下的领域目录。

- **创建新领域**：如果识别到新的知识领域，在 `20_Areas/knowledge/03notes/` 下自动创建对应目录（如 `01_react/`、`01_python/`、`02_算法设计/` 等）
- **使用现有领域**：如果知识属于已有领域，归类到对应目录
- **合并领域**：如果发现多个领域目录内容相似或重复，可以合并为一个领域
- **拆分领域**：如果某个领域目录内容过多或主题分散，可以拆分为多个更细粒度的领域
- **删除空领域**：如果某个领域目录为空或不再使用，可以删除
- **重命名领域**：如果领域名称不够准确，可以重命名目录

**分类原则**：以知识内容为核心，灵活调整领域结构，保持分类的合理性和可维护性。

---

#### 规则 C：参考资料 → Resources/Library

示例：

```text
源路径：50_Raw/inbox/20260113_143012_Python官方文档_inbox.pdf
或：50_Raw/merged/20260113_143500_编程资料_merged.pdf
目标路径：30_Resources/Library/Python官方文档.pdf
```

操作步骤：

1. 直接移动到 `30_Resources/Library/`
2. 如果需要，可以按类别创建子目录（如 `Library/Programming/`）

---

### 步骤 6：添加时间戳和标签

对每个移动的文件，自动添加元数据：

```yaml
---
created: 2026-01-13T10:30:00      # 捕捉时间
processed: 2026-01-13T23:00:00    # 处理时间
source: 50_Raw/inbox              # 来源
organizer_confidence: high        # 分类置信度（high/medium/low）
---
```

如果分类不确定（confidence: low），在文件名前加 `[待确认]` 前缀。

---

### 步骤 7：清空 50_Raw/

所有文件处理完成后，清空 `50_Raw/` 目录：

- 删除 `50_Raw/inbox/` 中的所有文件（已分类归位）
- 删除 `50_Raw/merged/` 中的所有文件（已分类归位）
- 删除 `50_Raw/` 中的其他临时文件
- 保留目录结构（不删除目录本身）

**清空逻辑**：
- 确认所有文件已成功移动到目标位置
- 确认没有文件遗漏
- 清空后 `50_Raw/` 应该只保留空目录结构

---

### 步骤 8：生成处理报告

所有文件处理完成后，生成报告：

```markdown
# Organizer 执行报告

**执行时间**：2026-01-13 23:00:00
**处理文件数**：12

## 合并统计

- 合并同类内容：5 个文件合并为 2 个文件
- 合并后文件保存在：`50_Raw/merged/`

## 分类归位统计

### 项目相关 → 20_Areas/Projects：2 个

- 项目A设计说明.md → 20_Areas/Projects/01_项目A/
- 项目B会议纪要.md → 20_Areas/Projects/02_项目B/

### 知识片段 → 20_Areas/knowledge/03notes：7 个

- React_useEffect_依赖数组.md → 20_Areas/knowledge/03notes/01_react/
- Python_装饰器用法.md → 20_Areas/knowledge/03notes/01_python/
- Docker容器优化.md → 20_Areas/knowledge/03notes/02_docker/ (新建领域)
- SQL索引优化.md → 20_Areas/knowledge/03notes/03_database/

## 领域分类统计

**领域分布情况**：

- 归并到现有领域：5 个（71%）
- 新建领域：2 个（29%）
- 待确认（低置信度）：0 个（0%）

**当前领域状态**：

- 总领域数：8 个
- 平均每领域文件数：12 个
- 最大领域：01_react (18 个文件)
- 建议 Distill：01_react, 01_python

### 参考资料 → Resources/Library：2 个

- Python官方文档.pdf → 30_Resources/Library/
- 设计模式图解.png → 30_Resources/Library/

## 待人工确认（低置信度）

- [待确认] 会议记录.txt → 20_Areas/knowledge/03notes/00_未分类/

## 50_Raw/ 状态

✅ 50_Raw/ 已清空！
```

将报告保存到：`30_Resources/summary/20260113_230000_组织分类报告_Organizer.md`

---

## 安全检查

在执行任何文件操作前，必须验证：

- [ ] 源路径在 `50_Raw/` 内
- [ ] 目标路径在白名单的**可写区域**内
- [ ] 不会覆盖 `manual/` 区域的任何文件
- [ ] 记录所有操作日志

---

## 特殊情况处理

### 情况 1：无法判断类型

- 移动到 `20_Areas/knowledge/03notes/00_未分类/`
- 文件名加 `[待确认]` 前缀
- 在报告中标注，等待人工介入

### 情况 2：同名文件冲突

- 在新文件名后加时间戳：`文件名_20260113103000.md`
- 记录冲突信息在报告中

### 情况 3：二进制文件

- 不尝试读取内容
- 只根据文件名和扩展名判断
- 默认分流到 `30_Resources/Library/`

### 情况 4：主题过度细分

如果关键词包含多层级（如 `React_Hooks_useEffect`）：

- 自动提取前 1-2 层作为主题（React）
- 其余作为子主题（Hooks_useEffect）

目标粒度：

- ✅ 具体技术：React, Python, Docker
- ✅ 特定领域：Database, Network, Security
- ❌ 过于宽泛：前端, 后端, 编程
- ❌ 过于具体：React_Hooks_useEffect

### 情况 5：跨领域知识

- **优先策略**：归并到主要领域（20_Areas/knowledge/03notes/01_python/）
- **备选策略**：如果交叉内容很多（10+ 个），创建独立领域目录（如 `03_python_database/`）

---

## 关键原则

1. **保守分类**：不确定时，标记为"待确认"
2. **元数据优先**：每个文件都要加元数据，方便追溯
3. **非破坏性**：移动文件，不删除，不修改原始内容
4. **可追溯**：生成详细报告，记录每个文件的去向
5. **白名单强制**：绝对不操作白名单外的路径
6. **智能归并优先**：优先归并到现有主题
7. **二级分类规范**：使用"子主题_内容"命名
8. **粒度适中**：主题不要过于宽泛或具体

---

## 主题管理目标

维护健康的主题结构：

**目标指标**：

- 一级主题总数：**≤ 20 个**
- 每个主题文件数：**10-50 个**
- 相似主题合并率：**≥ 80%**
- 待确认文件率：**≤ 10%**

**推荐领域列表**（参考）：

```text
技术栈：01_react, 01_python, 02_算法设计, 03_database
工具平台：04_git, 05_docker, 06_linux
通用主题：07_设计模式, 08_最佳实践, 09_错误模式
```

---

## 预期效果

通过 Organizer（含合并和分类），实现：

- ✅ 50_Raw/ 自动清空
- ✅ 信息自动分类到 PARA 体系
- ✅ 零人工干预（高置信度场景）
- ✅ 知识流动的第一步自动化
- ✅ 领域结构清晰有序
- ✅ 避免领域过度分散
- ✅ 按领域分类方便检索

---

## 附录：规范化规则参考

### 常用技术栈规范化

**编程语言**：React/ReactJS → React，Python3/Py → Python，JavaScript/JS → JavaScript
**数据库**：MySQL/PostgreSQL → Database，MongoDB → MongoDB（独立），Redis → Redis（独立）
**工具**：Docker/容器 → Docker，Git/GitHub/GitLab → Git，Kubernetes/K8s → Kubernetes
**特殊主题**：错误/Bug → Error_Patterns，最佳实践 → Best_Practices，性能优化 → Performance

### 扩展建议

根据实际使用情况，逐步扩展规范化规则：

1. **观察法**：运行几次 Organizer 后，查看是否出现相似领域（如 `01_react` 和 `01_reactjs`）
2. **手动归并**：发现重复领域时，人工归并并记录规则
3. **更新规则**：在领域分类逻辑中补充新规则

扩展原则：

- 优先使用官方名称或业界通用名称
- 宁可归并过多（后续可拆分），不要分散过细（难以整合）
- 主题总数控制在 20 个以内
